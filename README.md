# GeoHash #
GeoHash算法查找附近的POI（Point Of Interest，兴趣点），本项目以查找附近的餐厅为例。
## 目录
#### 1、GeoHash介绍
#### 2、GeoHash实现
#### 3、八邻接区域的获取
#### 4、字符串的匹配
#### 5、POI数据的获取

---------
<br>
#### 1、GeoHash介绍
GeoHash是地理编码方式，它将一个地理位置编码成为字母和数字的组合，可近似地理解为生成一个Hash值。<br><br>
其特点如下：<br>
1) GeoHash将地理位置的经度和纬度转化为字符串；<br>
2）该字符串表示的不是一个点，而是一个矩形区域；<br>
3）字符串越长表示划分的矩形区域越小，精度越高。<br><br>
总体思路：首先对餐厅数据进行GeoHash编码，保存入数据库；查找附近的餐厅时，将自己的地理信息编码后与数据库的GeoHash码进行前缀匹配，从而检索出附近的餐厅，为了增加准确性也需对八邻接区域的前缀进行检索。
#### 2、GeoHash实现
下面介绍GeoHash算法的具体实现，以我的学校坐标位置(121.5315824747,38.8801635622)为例。
##### 2.1 经度的GeoHash编码

GeoHash编码类似于二分法。<br>
首先经度（-180,180）平均分成两个区间（-180,0）、(0,180)，当目标经度位于前半区域时取0，位于后半区域时取1。121.5315824747位于(0,180)域取1。<br>
搜索区间变成（0,180），再分为两个区间（0,90），（90,180），121.5315824747位于后半区域(90,180)，取1。<br>
以此类推，直到精度符合要求为止，二分次数越多，取得的值就越精确。<br>
目标经度：121.5315824747，得到编码为1101 0110 0110 1100 0010。

|left|mid|right|编码|
|:-:|:-:|:-:|:-:|
|-180 |0 |180| 1|
|0 |90 |180 |1|
|90 |135 |180 |0|
|90 |112.5 |135 |1|
|112.5 |123.75 |135 |0|
|112.5 |118.125 |123.75 |1|
|...|...|...|...|
##### 2.2 纬度的GeoHash编码

目标纬度：38.8801635622，得到的编码为1011 0111 0100 1011 1101。

|left|mid|right|编码|
|:-:|:-:|:-:|:-:|
|-90 |0 |90 |1|
|0 |45 |90 |0|
|0 |22.5 |45 |1|
|22.5 |33.75 |45 |1|
|33.75 |39.375 |45 |0|
|...|...|...|...|

##### 2.3 合并经度、纬度的GeoHash编码
经度编码为1101 0110 0110 1100 0010<br>
纬度编码为1011 0111 0100 1011 1101<br>
经度、纬度交替合并经纬度编码，得到位置的GeoHash编码为：<br>
1110011100111101001110001110010101011001<br>
偶数为是经度，奇数为是纬度，这里说的奇数、偶数是值数组的下标，从0开始的
##### 2.4 进行Base32编码
将上面得到的01序列编码转为Base32码，每5位转换为1个十进制对应的Base32码。<br>
01序列：11100 11100 11110 10011 10001 11001 01010 11001<br>
十进制码：28 28 30 19 17 25 10 25<br>
Base32码：w w y m j t b t<br>
因此，求获得的GeoHash码为 wwymjtbt
> Base32编码表

|十进制值|Base32码||十进制值|Base32码||十进制值|Base32码||十进制值|Base32码|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|0|0| |8|8 | |16|h| |24|s|
|1|1| |9|9 | |17|j| |25|t|
|2|2| |10|b| |18|k| |26|u|
|3|3| |11|c| |19|m| |27|v|
|4|4| |12|d| |20|n| |28|w|
|5|5| |13|e| |21|p| |29|x|
|6|6| |14|f| |22|q| |30|y|
|7|7| |15|g| |23|r| |31|z|

>GeoHash长度与精度的关系如下表所示

|GeoHash长度	|Lat误差|Lng误差|km误差
|:-:|:-:|:-:|:-:|
|1|±23|±23|±2500|
|2|± 2.8|±5.6|±630|
|3|± 0.70|± 0.7|±78|
|4|± 0.087|± 0.18|±20|
|5|± 0.022|± 0.022|±2.4|
|6|± 0.0027|± 0.0055|±0.61|
|7|±0.00068|±0.00068|±0.076|
|8|±0.000086|±0.000172|±0.01911|
|9|±0.000021|±0.000021|±0.00478|
|10|±0.00000268|±0.00000536|±0.0005971|
|11|±0.00000067|±0.00000067|±0.0001492|
|12|±0.00000008|±0.00000017|±0.0000186|

我们GeoHash的编码长度为8，这时精度在19米左右。如果要找附近2km的POI，只需要匹配GeoHash值得前5位即可。
#### 3、八邻接区域的获取
为了提高搜索的准确性，需要加入周围八个区域的GeoHash值检索，我们已知当前点的坐标，以及精度要求可以每个区域的经度、纬度宽度，由此求得八邻接区域的坐标，再进行GeoHash编码。

|:-:|:-:|:-:|
|upperLeft|upper|upperRight|
|left|**center**|right|
|lowerLeft|lower|lowerRight|

#### 4、字符串的匹配
Trie树，又称前缀树、字典树，是一种树形结构，是一种哈希树的变种，可用于字符串的匹配、查找。Trie树的核心思想是空间换时间。利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。<br>
它的优点是：最大限度地减少无谓的字符串比较，查询效率比哈希表高。<br>
这里只用了简单的遍历方法，暂没有实现前缀树，无疑这种场景下使用前缀树是效率最高的。
#### 5、POI数据的获取

未完待续...